{"version":3,"sources":["webpack:///../src/LayoutWrapper.tsx","webpack:///../src/Picture.tsx","webpack:///../src/Placeholder.tsx","webpack:///../src/MainImage.tsx","webpack:///../src/lazyHydrate.tsx"],"names":["LayoutWrapper","layout","width","height","children","sizer","createElement","style","paddingTop","maxWidth","display","alt","role","src","Fragment","Image","srcSet","loading","shouldLoad","innerRef","props","decoding","ref","Picture","forwardRef","fallback","sources","fallbackImage","length","map","media","type","key","propTypes","PropTypes","isRequired","sizes","displayName","Placeholder","propName","componentName","Error","MainImage","lazyHydrate","root","hydrated","placeholder","images","isLoading","isLoaded","toggleIsLoaded","current","hasSSRHtml","querySelector","hasNativeLazyLoadSupport","cacheKey","JSON","stringify","hasLoaded","hasImageLoaded","component","getPlaceHolderProps","getMainProps","render","hydrate"],"mappings":"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","file":"18-9a4ad8b87092ac0688cd.js","sourcesContent":["/* global SERVER */\nimport { createElement, Fragment, FunctionComponent, ReactNode } from 'react';\n\nconst terserMacro = require('../macros/terser.macro');\n\nexport type LayoutWrapperProps = {\n  layout: 'intrinsic' | 'responsive' | 'fixed';\n  width: number;\n  height: number;\n};\n\nconst NativeScriptLoading = () => (\n  <script\n    type=\"module\"\n    dangerouslySetInnerHTML={{\n      __html: terserMacro`\nconst hasNativeLazyLoadSupport = typeof HTMLImageElement !== \"undefined\" && \"loading\" in HTMLImageElement.prototype;\nif (hasNativeLazyLoadSupport) {\n  const gatsbyImages = document.querySelectorAll('img[data-main-image]');\n  for (let mainImage of gatsbyImages) {\n    if (mainImage.dataset.src) {\n      mainImage.setAttribute('src', mainImage.dataset.src)\n      mainImage.removeAttribute('data-src')\n    }\n    if (mainImage.dataset.srcset) {\n      mainImage.setAttribute('srcset', mainImage.dataset.srcset)\n      mainImage.removeAttribute('data-srcset')\n    }\n\n    if (mainImage.complete) {\n      mainImage.style.opacity = 1;\n    }\n  }\n}\n`,\n    }}\n  />\n);\n\nexport const LayoutWrapper: FunctionComponent<LayoutWrapperProps> = function LayoutWrapper({\n  layout,\n  width,\n  height,\n  children,\n}) {\n  let sizer = null;\n  if (layout === 'responsive') {\n    sizer = <div style={{ paddingTop: `${(width / height) * 100}%` }} />;\n  }\n  if (layout === 'intrinsic') {\n    sizer = (\n      <div style={{ maxWidth: width, display: 'block' }}>\n        <img\n          alt=\"\"\n          role=\"presentation\"\n          aria-hidden=\"true\"\n          src={`data:image/svg+xml;charset=utf-8,%3Csvg height='${height}' width='${width}' xmlns='http://www.w3.org/2000/svg' version='1.1'%3E%3C/svg%3E`}\n          style={{\n            width: '100%',\n            display: 'inline-block',\n          }}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <Fragment>\n      {sizer}\n      {children}\n      {SERVER && <NativeScriptLoading />}\n    </Fragment>\n  );\n};\n","import {\n  createElement,\n  FunctionComponent,\n  ImgHTMLAttributes,\n  forwardRef,\n  LegacyRef,\n} from 'react';\nimport * as PropTypes from 'prop-types';\n\ntype ResponsiveImageProps = {\n  sizes?: string;\n  srcSet: string;\n};\n\nexport type SourceProps = ResponsiveImageProps &\n  (\n    | {\n        media: string;\n        type?: string;\n      }\n    | {\n        media?: string;\n        type: string;\n      }\n  );\n\ntype FallbackProps = { src: string } & Partial<ResponsiveImageProps>;\n\ntype ImageProps = ImgHTMLAttributes<{}> & {\n  src: string;\n  alt: string;\n  shouldLoad: boolean;\n  innerRef: LegacyRef<HTMLImageElement>;\n};\n\nexport type PictureProps = ImgHTMLAttributes<{}> & {\n  fallback: FallbackProps;\n  sources?: Array<SourceProps>;\n  alt: string;\n  shouldLoad?: boolean;\n};\n\nconst Image: FunctionComponent<ImageProps> = function Image({\n  src,\n  srcSet,\n  loading,\n  alt = '',\n  shouldLoad,\n  innerRef,\n  ...props\n}) {\n  return (\n    <img\n      {...props}\n      decoding=\"async\"\n      loading={loading}\n      src={shouldLoad ? src : null}\n      data-src={!shouldLoad ? src : null}\n      srcSet={shouldLoad ? srcSet : null}\n      data-srcset={!shouldLoad ? srcSet : null}\n      alt={alt}\n      // @ts-ignore\n      ref={innerRef}\n    />\n  );\n};\n\nexport const Picture = forwardRef<HTMLImageElement, PictureProps>(\n  function Picture(\n    { fallback, sources = [], shouldLoad = true, ...props },\n    ref\n  ) {\n    const fallbackImage = (\n      <Image {...props} {...fallback} shouldLoad={shouldLoad} innerRef={ref} />\n    );\n\n    if (!sources.length) {\n      return fallbackImage;\n    }\n\n    return (\n      <picture>\n        {sources.map(({ media, srcSet, type }) => {\n          return (\n            <source\n              key={`${media}-${type}-${srcSet}`}\n              type={type}\n              media={media}\n              srcSet={srcSet}\n            />\n          );\n        })}\n        {fallbackImage}\n      </picture>\n    );\n  }\n);\n\nImage.propTypes = {\n  src: PropTypes.string.isRequired,\n  alt: PropTypes.string.isRequired,\n  sizes: PropTypes.string,\n  srcSet: PropTypes.string,\n  shouldLoad: PropTypes.bool,\n};\n\nPicture.displayName = 'Picture';\nPicture.propTypes = {\n  alt: PropTypes.string.isRequired,\n  shouldLoad: PropTypes.bool,\n  fallback: PropTypes.exact({\n    src: PropTypes.string.isRequired,\n    srcSet: PropTypes.string,\n    sizes: PropTypes.string,\n  }),\n  sources: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.exact({\n        media: PropTypes.string.isRequired,\n        type: PropTypes.string,\n        sizes: PropTypes.string,\n        srcSet: PropTypes.string.isRequired,\n      }),\n      PropTypes.exact({\n        media: PropTypes.string,\n        type: PropTypes.string.isRequired,\n        sizes: PropTypes.string,\n        srcSet: PropTypes.string.isRequired,\n      }),\n    ])\n  ),\n};\n","import { createElement, FunctionComponent, ImgHTMLAttributes } from 'react';\nimport * as PropTypes from 'prop-types';\nimport { Picture, SourceProps } from './Picture';\n\nexport type PlaceholderProps = ImgHTMLAttributes<{}> & {\n  fallback: string;\n  sources?: Array<SourceProps>;\n};\n\nexport const Placeholder: FunctionComponent<PlaceholderProps> = function Placeholder({\n  fallback,\n  ...props\n}) {\n  return (\n    <Picture\n      {...props}\n      fallback={{\n        src: fallback,\n      }}\n      aria-hidden\n      alt=\"\"\n    />\n  );\n};\n\nPlaceholder.displayName = 'Placeholder';\nPlaceholder.propTypes = {\n  fallback: PropTypes.string.isRequired,\n  sources: Picture.propTypes.sources,\n  alt: function (props, propName, componentName) {\n    if (props[propName]) {\n      return new Error(\n        'Invalid prop `' +\n          propName +\n          '` supplied to' +\n          ' `' +\n          componentName +\n          '`. Validation failed.'\n      );\n    }\n  },\n};\n","import { createElement, forwardRef, Fragment } from 'react';\nimport * as PropTypes from 'prop-types';\nimport { Picture, PictureProps } from './Picture';\n\nexport type MainImageProps = PictureProps;\n\nexport const MainImage = forwardRef<HTMLImageElement, MainImageProps>(\n  function MainImage({ ...props }, ref) {\n    return <Picture ref={ref} {...props} />;\n  }\n);\n\nMainImage.displayName = 'MainImage';\nMainImage.propTypes = Picture.propTypes;\n","import { createElement, RefObject, MutableRefObject } from 'react';\nimport { hydrate, render } from 'react-dom';\nimport { GatsbyImageProps } from './GatsbyImage.browser';\nimport { LayoutWrapper } from './LayoutWrapper';\nimport { Placeholder } from './Placeholder';\nimport { MainImageProps, MainImage } from './MainImage';\nimport {\n  getMainProps,\n  getPlaceHolderProps,\n  hasNativeLazyLoadSupport,\n  hasImageLoaded,\n} from './hooks';\n\ntype LazyHydrateProps = Omit<GatsbyImageProps, 'as' | 'style' | 'className'> & {\n  isLoading: boolean;\n  isLoaded: boolean; // alwaystype SetStateAction<S> = S | ((prevState: S) => S);\n  toggleIsLoaded: Function;\n  ref: MutableRefObject<HTMLImageElement>;\n};\n\nexport function lazyHydrate(\n  {\n    layout = 'fixed',\n    width,\n    height,\n    placeholder,\n    images,\n    loading,\n    isLoading,\n    isLoaded,\n    toggleIsLoaded,\n    ref,\n    ...props\n  }: LazyHydrateProps,\n  root: RefObject<HTMLElement>,\n  hydrated: MutableRefObject<boolean>\n) {\n  if (!root.current) {\n    return;\n  }\n\n  const hasSSRHtml = root.current.querySelector('[data-gatsby-image-ssr]');\n  // On first server hydration do nothing\n  if (hasNativeLazyLoadSupport && hasSSRHtml && !hydrated.current) {\n    return;\n  }\n\n  const cacheKey = JSON.stringify(images);\n  const hasLoaded = !hydrated.current && hasImageLoaded(cacheKey);\n\n  const component = (\n    <LayoutWrapper layout={layout} width={width} height={height}>\n      {!hasLoaded && placeholder && (\n        <Placeholder {...getPlaceHolderProps(placeholder)} />\n      )}\n      <MainImage\n        {...(props as Omit<MainImageProps, 'images' | 'fallback'>)}\n        {...getMainProps(\n          isLoading,\n          hasLoaded || isLoaded,\n          images,\n          loading,\n          toggleIsLoaded,\n          cacheKey,\n          ref\n        )}\n      />\n    </LayoutWrapper>\n  );\n\n  const doRender = hydrated.current ? render : hydrate;\n  doRender(component, root.current);\n  hydrated.current = true;\n\n  return () => {\n    if (root.current) {\n      render(null, root.current);\n    }\n  };\n}\n"],"sourceRoot":""}